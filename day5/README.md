## TSP CHALLENGE

#### アルゴリズム
1. 初期（Greedy）
2. 2-opt

#### 距離比較


|                  | 0             | 1             | 2            | 3             | 4            | 5             | 6             |
| -------------    | ------------- | ------------- |------------- | ------------- |------------- | ------------- | ------------- |
| greedy           |    3418.10    | 3832.29       | 5449.44      | 10519.16      | 12684.06     | 25331.84      | 49892.05      |
| 2-opt            |    3418.10    |     3832.29   |     4994.89  |   8970.05     |    11489.79  |    21363.60   |   42712.37    |
| 2-opt /start = 1 |    3418.10    |     3832.29   |     4494.89  |   8704.37     |    11293.73  |    21792.97   |   42533.04    |
| 2-opt /start = 2 |    3418.10    |     3832.29   |     4670.27  |   8691.10     |    11288.43  |    21428.82   |   41999.64    |

#### 考え方
2-opt<br>
ルート上で、都市間の距離（エッジ）を2つ選択し、それを入れ替えることで<br>
新たなルートを試みる<br>
もし新たなルートが前のルートよりも距離が短い場合、新しいルートに書き換える<br>
これをすべてのエッジの組み合わせに対して試す<br><br>

【root1】<br>
[0, 1, 2, 3, 4, 5]<br><br>

0 -- 1 -- 2<br>
|　　　　|<br>
5 -- 4 -- 3<br><br>

【root2】<br>
[0, 1, 3, 2, 4, 5]<br><br>

0 -- 1　　2<br>
|　　　✕　|<br>
5 -- 4　　3<br>

もし、root2の方が、root1よりも短距離な場合、入れ替える

#### コード

```
# 2-opt
def two_opt(tour, dist):
    while True:
        updata = False
        for i in range(len(tour) - 2):
            for j in range(i + 2, len(tour)):
                root1 = dist[tour[i]][tour[i+1]] + dist[tour[j]][tour[(j+1)%len(tour)]]
                root2 = dist[tour[i]][tour[j]] + dist[tour[i+1]][tour[(j+1)%len(tour)]]
                if root1 > root2:
                    tour[i+1:j+1] = reversed(tour[i+1:j+1])
                    updata = True
        if not updata:
            break
    return tour
```

都市i&jの距離間が保存されている2次元配列のdistから、距離を出す<br>
root1とroot2を比べて、条件に合わせて訪れる順番を変更する<br>
i+1から、jまでの順番を逆にする

#### これから
まだ、2-optまでの実装しか手を動かせていないので、他の実装も取り組みたい


## week2
greedy + 2-optで行うと、start = 2の時が、短かった
